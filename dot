#!/usr/bin/env bash

set -euo pipefail

# Colors for output
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[0;33m'
readonly BLUE='\033[0;34m'
readonly CYAN='\033[0;36m'
readonly RESET='\033[0m'
readonly BOLD='\033[1m'

# Script metadata
readonly SCRIPT_NAME="dot"
readonly VERSION="1.0.0"
DOTFILES_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DOTFILES_DIR

# Configuration
readonly PACKAGES_DIR="${DOTFILES_DIR}/packages"
readonly HOME_DIR="${DOTFILES_DIR}/home"
readonly GITHUB_EMAIL="dillon.mulroy@gmail.com"
readonly GITHUB_KEY_PATH="${HOME}/.ssh/id_ed25519_github"
readonly FONT_REPO_URL="git@github.com:dmmulroy/mono-lisa.git"

# Progress indicators
CURRENT_STEP=0
TOTAL_STEPS=0

# Helper functions
print_header() {
    echo -e "\n${BOLD}${BLUE}==>${RESET} ${BOLD}$1${RESET}"
}

print_success() {
    echo -e "${GREEN}✓${RESET} $1"
}

print_error() {
    echo -e "${RED}✗${RESET} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}⚠${RESET} $1"
}

print_info() {
    echo -e "${CYAN}ℹ${RESET} $1"
}

print_step() {
    ((CURRENT_STEP++))
    echo -e "\n${BOLD}[${CURRENT_STEP}/${TOTAL_STEPS}]${RESET} $1"
}

command_exists() {
    command -v "$1" >/dev/null 2>&1
}

confirm() {
    local prompt="${1:-Continue?}"
    local default="${2:-n}"
    
    if [[ "$default" == "y" ]]; then
        prompt="$prompt [Y/n]: "
    else
        prompt="$prompt [y/N]: "
    fi
    
    read -r -p "$prompt" response
    
    case "$response" in
        [yY][eE][sS]|[yY]) return 0 ;;
        [nN][oO]|[nN]) return 1 ;;
        "")
            if [[ "$default" == "y" ]]; then
                return 0
            else
                return 1
            fi
            ;;
        *) return 1 ;;
    esac
}

check_dependencies() {
    local deps=("$@")
    local missing=()
    
    for dep in "${deps[@]}"; do
        if ! command_exists "$dep"; then
            missing+=("$dep")
        fi
    done
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        print_error "Missing dependencies: ${missing[*]}"
        return 1
    fi
    
    return 0
}

# Installation functions
install_homebrew() {
    print_step "Installing Homebrew"
    
    if command_exists brew; then
        print_success "Homebrew is already installed"
        return 0
    fi
    
    print_info "Homebrew is not installed. Installing now..."
    
    # Create temporary log file for installation output
    local log_file
    log_file=$(mktemp)
    local exit_code=0
    
    print_info "Running Homebrew installer (non-interactive mode)..."
    
    # Run installer with non-interactive flag and capture output
    if NONINTERACTIVE=1 /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" > "$log_file" 2>&1; then
        print_success "Homebrew installation successful"
        
        # Configure Homebrew environment for the current session
        print_info "Configuring Homebrew environment..."
        if [[ "$(uname -m)" == "arm64" ]]; then
            eval "$(/opt/homebrew/bin/brew shellenv)"
        else
            eval "$(/usr/local/bin/brew shellenv)"
        fi
        print_success "Homebrew environment configured"
    else
        exit_code=$?
        print_error "Homebrew installation failed (exit code: $exit_code)"
        
        # Surface errors from the log
        print_info "Installation output:"
        if [[ -s "$log_file" ]]; then
            # Show last 20 lines of output for context
            tail -20 "$log_file" | while IFS= read -r line; do
                echo "  $line"
            done
        else
            print_warning "No installation output captured"
        fi
        
        # Common troubleshooting hints
        print_info "Troubleshooting:"
        print_info "  - Check if you have sufficient disk space"
        print_info "  - Ensure you have admin privileges"
        print_info "  - Check network connectivity"
        print_info "  - Try running manually: /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
        
        rm "$log_file"
        return 1
    fi
    
    # Cleanup log file
    rm "$log_file"
}

install_packages() {
    print_step "Installing packages from Brewfile"
    
    if [[ ! -f "${PACKAGES_DIR}/bundle" ]]; then
        print_error "Base Brewfile not found at ${PACKAGES_DIR}/bundle"
        return 1
    fi
    
    print_info "Installing base packages..."
    
    # Try to install all packages at once first
    if brew bundle --file="${PACKAGES_DIR}/bundle" --no-lock; then
        print_success "All base packages installed successfully"
    else
        print_warning "Some packages failed to install, trying individually..."
        
        # Parse Brewfile and try to install packages one by one
        local failed_packages=()
        local installed_count=0
        
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            # Extract package type and name
            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                print_info "Installing brew package: $package"
                if brew install "$package" 2>/dev/null; then
                    ((installed_count++))
                else
                    print_warning "Failed to install: $package"
                    failed_packages+=("brew:$package")
                fi
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                print_info "Installing cask: $package"
                if brew install --cask "$package" 2>/dev/null; then
                    ((installed_count++))
                else
                    print_warning "Failed to install: $package"
                    failed_packages+=("cask:$package")
                fi
            fi
        done < "${PACKAGES_DIR}/bundle"
        
        if [[ ${#failed_packages[@]} -gt 0 ]]; then
            print_warning "Failed to install ${#failed_packages[@]} packages:"
            printf "  - %s\n" "${failed_packages[@]}"
            
            # Save failed packages to a file for reference
            local failed_file
            failed_file="${PACKAGES_DIR}/failed_packages_$(date +%Y%m%d_%H%M%S).txt"
            printf "%s\n" "${failed_packages[@]}" > "$failed_file"
            print_info "Failed packages saved to: $failed_file"
        fi
        
        print_success "Successfully installed $installed_count packages"
    fi
    
    # Work packages
    if [[ -f "${PACKAGES_DIR}/bundle.work" ]] && confirm "Install work-specific packages?" "n"; then
        print_info "Installing work packages..."
        if brew bundle --file="${PACKAGES_DIR}/bundle.work" --no-lock; then
            print_success "Work packages installed successfully"
        else
            print_warning "Some work packages failed to install"
            
            # Try individual installation for work packages too
            local work_failed=()
            while IFS= read -r line; do
                [[ "$line" =~ ^[[:space:]]*# ]] && continue
                [[ -z "${line// }" ]] && continue
                
                if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                    local package="${BASH_REMATCH[1]}"
                    print_info "Installing work package: $package"
                    if ! brew install "$package" 2>/dev/null; then
                        work_failed+=("$package")
                    fi
                fi
            done < "${PACKAGES_DIR}/bundle.work"
            
            if [[ ${#work_failed[@]} -gt 0 ]]; then
                print_warning "Failed work packages: ${work_failed[*]}"
            fi
        fi
    fi
}

stow_dotfiles() {
    print_step "Stowing configuration files"
    
    if ! command_exists stow; then
        print_error "GNU Stow is not installed"
        print_info "Please install stow via Homebrew: brew install stow"
        return 1
    fi
    
    print_info "Stowing files from ${HOME_DIR} to ${HOME}..."
    
    # Create backup directory for existing configs
    local backup_dir
    backup_dir="${DOTFILES_DIR}/backups/$(date +%Y%m%d_%H%M%S)"
    local files_to_backup=()
    
    # Check for existing files that would be overwritten
    while IFS= read -r -d '' file; do
        local relative_path="${file#"${HOME_DIR}"/}"
        local target_path="${HOME}/${relative_path}"
        
        if [[ -e "$target_path" && ! -L "$target_path" ]]; then
            files_to_backup+=("$relative_path")
        fi
    done < <(find "${HOME_DIR}" -type f -print0)
    
    if [[ ${#files_to_backup[@]} -gt 0 ]]; then
        print_warning "The following files will be replaced:"
        printf "  %s\n" "${files_to_backup[@]}"
        
        if confirm "Create backups of existing files?" "y"; then
            mkdir -p "$backup_dir"
            for file in "${files_to_backup[@]}"; do
                local src="${HOME}/${file}"
                local dst="${backup_dir}/${file}"
                mkdir -p "$(dirname "$dst")"
                cp -p "$src" "$dst"
            done
            print_success "Backups created in ${backup_dir}"
        fi
    fi
    
    if stow -R -v -d "${DOTFILES_DIR}" -t "${HOME}" home; then
        print_success "Dotfiles stowed successfully"
    else
        print_error "Failed to stow dotfiles"
        return 1
    fi
}

install_bun() {
    print_step "Installing Bun"
    
    if command_exists bun; then
        print_success "Bun is already installed"
        return 0
    fi
    
    print_info "Installing Bun..."
    if curl -fsSL https://bun.sh/install | bash; then
        print_success "Bun installed successfully"
    else
        print_error "Failed to install Bun"
        return 1
    fi
}

install_claude_code() {
    print_step "Installing Claude Code CLI"
    
    # Save current shell options for restoration
    local _saved_opts="$-"
    
    # Check if Claude Code is already installed
    if command_exists claude; then
        print_success "Claude Code is already installed"
        # Check if it's the correct version (npm package)
        local claude_path
        claude_path=$(command -v claude)
        if [[ "$claude_path" == *".bun"* ]] || [[ "$claude_path" == *"node_modules"* ]]; then
            print_success "Claude Code is installed via package manager"
            # Restore shell options before returning
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        fi
    fi
    
    print_info "Installing Claude Code CLI..."
    
    # Temporarily disable exit on error for installation attempts
    set +e
    
    # Try bun first (faster), fallback to npm
    if command_exists bun; then
        print_info "Installing via Bun..."
        if bun install -g @anthropic-ai/claude-code; then
            print_success "Claude Code installed successfully via Bun"
            # Restore shell options before returning
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        else
            print_warning "Bun installation failed, trying npm..."
        fi
    fi
    
    # Fallback to npm
    if command_exists npm; then
        print_info "Installing via npm..."
        if npm install -g @anthropic-ai/claude-code; then
            print_success "Claude Code installed successfully via npm"
            # Restore shell options before returning
            set -"$_saved_opts" 2>/dev/null || true
            return 0
        else
            print_error "Failed to install Claude Code via npm"
            # Restore shell options before returning
            set -"$_saved_opts" 2>/dev/null || true
            return 1
        fi
    else
        print_error "Neither Bun nor npm is available for installing Claude Code"
        print_info "Please install Node.js/npm or Bun first"
        # Restore shell options before returning
        set -"$_saved_opts" 2>/dev/null || true
        return 1
    fi
}

generate_ssh_key() {
    print_step "Generating SSH key for GitHub"
    
    if [[ -f "$GITHUB_KEY_PATH" ]]; then
        print_success "SSH key already exists at $GITHUB_KEY_PATH"
        return 0
    fi
    
    print_info "Generating new SSH key..."
    mkdir -p "${HOME}/.ssh"
    chmod 700 "${HOME}/.ssh"
    
    if ssh-keygen -t ed25519 -C "$GITHUB_EMAIL" -f "$GITHUB_KEY_PATH"; then
        print_success "SSH key generated successfully"
        print_info "Add the public key to GitHub:"
        echo "  pbcopy < ${GITHUB_KEY_PATH}.pub"
        echo "  Then go to: GitHub > Settings > SSH and GPG keys > New SSH key"
    else
        print_error "Failed to generate SSH key"
        return 1
    fi
}

install_font() {
    print_step "Installing MonoLisa font"

    if [[ ! -f "$GITHUB_KEY_PATH" ]]; then
        print_warning "GitHub SSH key not found. Skipping font installation"
        return 0
    fi

    if ! confirm "Have you added the SSH key to your GitHub account?" "n"; then
        print_warning "Skipping font installation"
        return 0
    fi

    local font_temp_dir
    font_temp_dir=$(mktemp -d)
    local font_install_dir="${HOME}/Library/Fonts"

    print_info "Cloning font repository..."
    if GIT_SSH_COMMAND="ssh -i $GITHUB_KEY_PATH -o IdentitiesOnly=yes" git clone "$FONT_REPO_URL" "$font_temp_dir"; then
        print_success "Repository cloned successfully"

        mkdir -p "$font_install_dir"
        print_info "Installing font files..."

        local font_count=0
        while IFS= read -r -d '' font_file; do
            cp "$font_file" "$font_install_dir/"
            ((font_count++))
        done < <(find "$font_temp_dir" -name '*.otf' -print0)

        if [[ $font_count -gt 0 ]]; then
            print_success "Installed $font_count font files"
        else
            print_warning "No font files found in repository"
        fi
    else
        print_error "Failed to clone font repository"
    fi

    rm -rf "$font_temp_dir"
}

cmd_gen_ssh_key() {
    print_header "Generating SSH key for GitHub"

    # Parse options
    local email=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} gen-ssh-key [EMAIL]

${BOLD}DESCRIPTION:${RESET}
    Generate a new SSH key for GitHub, GitLab, or other Git services.
    The key will be automatically added to ssh-agent and the public key
    will be copied to your clipboard for easy pasting.

${BOLD}ARGUMENTS:${RESET}
    EMAIL               Email address to associate with the SSH key (optional)
                        If not provided, you will be prompted for it

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} gen-ssh-key                          # Prompts for email
    ${SCRIPT_NAME} gen-ssh-key user@github.com          # Uses provided email
    ${SCRIPT_NAME} gen-ssh-key work@company.com         # Creates work key

${BOLD}NOTES:${RESET}
    - Key name is derived from email domain (e.g., user@github.com → id_ed25519_github)
    - Keys are stored in ~/.ssh/
    - Public key is automatically copied to clipboard
    - Key is automatically added to ssh-agent
    - If a key already exists, you will be prompted to overwrite

EOF
                return 0
                ;;
            *)
                email="$1"
                shift
                ;;
        esac
    done

    # Get email if not provided
    if [[ -z "$email" ]]; then
        read -r -p "Enter email address for SSH key: " email
        if [[ -z "$email" ]]; then
            print_error "Email is required"
            return 1
        fi
    fi

    # Validate email format (basic check)
    if [[ ! "$email" =~ ^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$ ]]; then
        print_error "Invalid email format: $email"
        return 1
    fi

    # Extract domain from email for key naming
    local domain
    domain=$(echo "$email" | sed 's/.*@//' | sed 's/\..*//')
    if [[ -z "$domain" ]]; then
        domain="key"
    fi

    # Sanitize domain name (remove special characters)
    domain=$(echo "$domain" | tr -cd '[:alnum:]_-' | tr '[:upper:]' '[:lower:]')

    # Set key path
    local key_name="id_ed25519_${domain}"
    local key_path="${HOME}/.ssh/${key_name}"

    print_info "Key will be created at: $key_path"

    # Check if key already exists
    if [[ -f "$key_path" ]]; then
        print_warning "SSH key already exists at $key_path"
        if ! confirm "Overwrite existing key?" "n"; then
            print_info "Key generation cancelled"
            return 0
        fi

        # Backup existing key
        local backup_path
        backup_path="${key_path}.backup.$(date +%Y%m%d_%H%M%S)"
        print_info "Backing up existing key to $(basename "$backup_path")"
        cp "$key_path" "$backup_path"
        cp "${key_path}.pub" "${backup_path}.pub" 2>/dev/null || true
    fi

    # Ensure .ssh directory exists with correct permissions
    mkdir -p "${HOME}/.ssh"
    chmod 700 "${HOME}/.ssh"

    # Generate SSH key
    print_info "Generating SSH key..."
    if ssh-keygen -t ed25519 -C "$email" -f "$key_path" -N ""; then
        print_success "SSH key generated successfully"
    else
        print_error "Failed to generate SSH key"
        return 1
    fi

    # Add key to ssh-agent
    print_info "Adding key to ssh-agent..."

    # Start ssh-agent if not running
    if ! pgrep -u "$USER" ssh-agent > /dev/null 2>&1; then
        print_info "Starting ssh-agent..."
        eval "$(ssh-agent -s)" > /dev/null
    fi

    if ssh-add "$key_path" 2>/dev/null; then
        print_success "Key added to ssh-agent"
    else
        print_warning "Failed to add key to ssh-agent (you may need to start ssh-agent)"
    fi

    # Copy public key to clipboard
    if command_exists pbcopy; then
        pbcopy < "${key_path}.pub"
        print_success "Public key copied to clipboard!"
    else
        print_warning "pbcopy not available, skipping clipboard copy"
    fi

    # Display instructions
    echo ""
    print_info "Next steps:"
    echo "  1. The public key has been copied to your clipboard"
    echo "  2. Go to your Git service (GitHub, GitLab, etc.):"
    echo "     - GitHub: Settings > SSH and GPG keys > New SSH key"
    echo "     - GitLab: Preferences > SSH Keys"
    echo "  3. Paste the key and save"
    echo ""
    print_info "Key details:"
    echo "  Private key: $key_path"
    echo "  Public key:  ${key_path}.pub"
    echo "  Email:       $email"
    echo ""

    # Show public key
    print_info "Public key contents:"
    cat "${key_path}.pub"
    echo ""

    print_success "SSH key generation complete!"
}

setup_fish_shell() {
    print_step "Setting up Fish shell"
    
    if ! command_exists fish; then
        print_error "Fish shell is not installed"
        return 1
    fi
    
    local fish_path
    fish_path=$(command -v fish)
    
    # Add fish to /etc/shells if needed
    if ! grep -q "$fish_path" /etc/shells; then
        print_info "Adding Fish to /etc/shells..."
        echo "$fish_path" | sudo tee -a /etc/shells >/dev/null
        print_success "Fish added to /etc/shells"
    fi
    
    # Set fish as default shell
    if [[ "$SHELL" != "$fish_path" ]]; then
        print_info "Setting Fish as default shell..."
        if chsh -s "$fish_path"; then
            print_success "Default shell changed to Fish"
            print_info "Please log out and back in for changes to take effect"
        else
            print_error "Failed to change default shell"
            return 1
        fi
    else
        print_success "Fish is already the default shell"
    fi
    
    # Install Fisher plugins
    print_info "Installing Fish plugins..."
    if fish -c "fisher install jhillyerd/plugin-git" 2>/dev/null; then
        print_success "Fish plugins installed"
    else
        print_warning "Failed to install some Fish plugins"
    fi
}

# Command functions
cmd_init() {
    print_header "Initializing dotfiles"
    
    TOTAL_STEPS=8
    CURRENT_STEP=0
    
    # Run all installation steps
    install_homebrew || return 1
    install_packages || return 1
    stow_dotfiles || return 1
    install_bun || return 1
    install_claude_code || print_warning "Claude Code installation failed (continuing)"
    
    if [[ "${SKIP_SSH:-}" != "true" ]]; then
        generate_ssh_key || print_warning "SSH key generation failed (continuing)"
    fi
    
    if [[ "${SKIP_FONT:-}" != "true" ]]; then
        install_font || print_warning "Font installation failed (continuing)"
    fi
    
    setup_fish_shell || print_warning "Fish shell setup failed (continuing)"
    
    print_header "Initialization complete! 🎉"
}

cmd_update() {
    print_header "Updating dotfiles"
    
    # Pull latest changes
    print_info "Pulling latest changes..."
    if git -C "$DOTFILES_DIR" pull; then
        print_success "Repository updated"
    else
        print_error "Failed to update repository"
        return 1
    fi
    
    # Update packages
    if confirm "Update Homebrew packages?" "y"; then
        print_info "Updating Homebrew..."
        brew update
        brew upgrade
        print_success "Packages updated"
    fi
    
    # Re-stow dotfiles
    if confirm "Re-stow dotfiles?" "y"; then
        stow_dotfiles
    fi
}

cmd_doctor() {
    print_header "Running diagnostics"
    
    local issues=0
    
    # Check Homebrew
    if command_exists brew; then
        print_success "Homebrew installed"
    else
        print_error "Homebrew not installed"
        ((issues++))
    fi
    
    # Check Stow
    if command_exists stow; then
        print_success "GNU Stow installed"
    else
        print_error "GNU Stow not installed"
        ((issues++))
    fi
    
    # Check Fish
    if command_exists fish; then
        print_success "Fish shell installed"
        if [[ "$SHELL" == "$(command -v fish)" ]]; then
            print_success "Fish is default shell"
        else
            print_warning "Fish is not default shell"
        fi
    else
        print_error "Fish shell not installed"
        ((issues++))
    fi
    
    # Check Claude Code
    if command_exists claude; then
        print_success "Claude Code installed"
        
        # Check installation method
        local claude_path
        claude_path=$(command -v claude)
        if [[ "$claude_path" == *".bun"* ]]; then
            print_success "Claude Code installed via Bun (recommended)"
        elif [[ "$claude_path" == *"node_modules"* ]]; then
            print_success "Claude Code installed via npm (recommended)"
        else
            print_warning "Claude Code installed via non-standard method"
            print_info "Consider reinstalling via: bun install -g @anthropic-ai/claude-code"
        fi
        
        # Check if we can get version (indicates it's working)
        if claude --version >/dev/null 2>&1; then
            print_success "Claude Code is functional"
        else
            print_warning "Claude Code may need authentication"
            print_info "Run 'claude auth login' to authenticate"
        fi
    else
        print_warning "Claude Code not installed"
        print_info "Install with: bun install -g @anthropic-ai/claude-code (or npm install -g @anthropic-ai/claude-code)"
    fi
    
    # Check symlinks
    local broken_links=0
    while IFS= read -r -d '' link; do
        if [[ ! -e "$link" ]]; then
            ((broken_links++))
        fi
    done < <(find "${HOME}" -maxdepth 3 -type l -print0 2>/dev/null)
    
    if [[ $broken_links -eq 0 ]]; then
        print_success "No broken symlinks found"
    else
        print_warning "Found $broken_links broken symlinks"
    fi
    
    # Check SSH key
    if [[ -f "$GITHUB_KEY_PATH" ]]; then
        print_success "GitHub SSH key exists"
    else
        print_warning "GitHub SSH key not found"
    fi
    
    # Check key development tools
    local dev_tools=("git" "nvim" "tmux" "node" "npm" "bun")
    local missing_tools=()
    
    for tool in "${dev_tools[@]}"; do
        if command_exists "$tool"; then
            print_success "$tool is available"
        else
            missing_tools+=("$tool")
        fi
    done
    
    if [[ ${#missing_tools[@]} -gt 0 ]]; then
        print_warning "Missing development tools: ${missing_tools[*]}"
    fi
    
    # Check if Fish plugins are installed (Fisher)
    if command_exists fish && command_exists fisher; then
        print_success "Fisher (Fish plugin manager) is available"
    elif command_exists fish; then
        print_warning "Fisher not installed - Fish plugins may not work"
    fi
    
    # Check if dotfiles directory is in PATH
    if echo "$PATH" | grep -q "$DOTFILES_DIR"; then
        print_success "Dotfiles directory is in PATH"
    else
        print_warning "Dotfiles directory not in PATH - 'dot' command may not work globally"
        if [[ "$SHELL" == *"fish"* ]]; then
            print_info "Run 'source ~/.config/fish/config.fish' or restart shell to fix"
        else
            print_info "Add 'export PATH=\"$DOTFILES_DIR:\$PATH\"' to your shell profile"
        fi
    fi
    
    if [[ $issues -eq 0 ]]; then
        print_header "All critical checks passed! ✨"
        if [[ ${#missing_tools[@]} -gt 0 ]]; then
            print_info "Note: Some optional tools are missing but core functionality is intact"
        fi
    else
        print_header "Found $issues critical issues"
    fi
}

cmd_backup() {
    local subcommand="${1:-create}"
    shift || true
    
    case "$subcommand" in
        create)
            cmd_backup_create "$@"
            ;;
        restore)
            cmd_backup_restore "$@"
            ;;
        list)
            cmd_backup_list "$@"
            ;;
        clean)
            cmd_backup_clean "$@"
            ;;
        compress)
            cmd_backup_compress "$@"
            ;;
        delete)
            cmd_backup_delete "$@"
            ;;
        -h|--help|help)
            cmd_backup_help
            ;;
        *)
            # If the subcommand looks like a backup name (no dashes, alphanumeric), 
            # treat it as 'create <name>'
            if [[ "$subcommand" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                cmd_backup_create "$subcommand" "$@"
            else
                print_error "Unknown backup subcommand: $subcommand"
                print_info "Run '${SCRIPT_NAME} backup help' for usage"
                return 1
            fi
            ;;
    esac
}

cmd_backup_create() {
    print_header "Creating backup of current configuration"
    
    local backup_name="${1:-backup-$(date +%Y%m%d-%H%M%S)}"
    local backup_root="${HOME}/.dotbackups"
    local backup_dir="${backup_root}/${backup_name}"
    local backup_archive="${backup_dir}.tar.gz"
    
    # Create temporary directory for staging
    local backup_temp_dir
    backup_temp_dir=$(mktemp -d -t DOT_backup_XXXXXX)
    
    print_info "Creating backup..."
    mkdir -p "$backup_temp_dir/$backup_name"
    
    # Find all symlinks pointing to our dotfiles
    local count=0
    while IFS= read -r -d '' file; do
        local relative_path="${file#"${HOME_DIR}"/}"
        local source_path="${HOME}/${relative_path}"
        
        if [[ -L "$source_path" ]]; then
            local target_dir
            target_dir="$backup_temp_dir/$backup_name/$(dirname "$relative_path")"
            mkdir -p "$target_dir"
            # Copy the actual file content, not the symlink itself
            if cp -L "$source_path" "$backup_temp_dir/$backup_name/${relative_path}" 2>/dev/null; then
                ((count++))
            else
                # Fallback: if the symlink target doesn't exist, copy the link
                cp -P "$source_path" "$backup_temp_dir/$backup_name/${relative_path}" 2>/dev/null && ((count++))
            fi
        fi
    done < <(find "${HOME_DIR}" -type f -print0)
    
    if [[ $count -eq 0 ]]; then
        print_warning "No symlinks found to backup"
        rm -rf "$backup_temp_dir"
        return 0
    fi
    
    # Create compressed archive
    print_info "Compressing backup ($count files)..."
    mkdir -p "$backup_root"
    
    if tar -czf "$backup_archive" -C "$backup_temp_dir" "$backup_name"; then
        local archive_size
        archive_size=$(du -h "$backup_archive" | cut -f1)
        print_success "Backup created: ${backup_archive} (${archive_size})"
        print_info "Backed up $count configuration files"
        rm -rf "$backup_temp_dir"
    else
        print_error "Failed to create backup archive"
        rm -rf "$backup_temp_dir"
        return 1
    fi
}

cmd_backup_restore() {
    print_header "Restoring configuration from backup"
    
    local backup_name="${1:-}"
    if [[ -z "$backup_name" ]]; then
        # List available backups
        print_info "Available backups:"
        if [[ -d "${HOME}/.dotbackups" ]]; then
            local found_backups=false
            
            # List compressed backups
            for backup in "${HOME}/.dotbackups"/*.tar.gz; do
                if [[ -f "$backup" ]]; then
                    local name
                    name=$(basename "$backup" .tar.gz)
                    local size
                    size=$(du -h "$backup" | cut -f1)
                    local date
                    date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$backup" 2>/dev/null || stat -c "%y" "$backup" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1)
                    echo "  - $name (${size}, $date)"
                    found_backups=true
                fi
            done
            
            # List uncompressed backups (legacy)
            for backup in "${HOME}/.dotbackups"/*; do
                if [[ -d "$backup" ]]; then
                    local name
                    name=$(basename "$backup")
                    echo "  - $name (uncompressed, legacy)"
                    found_backups=true
                fi
            done
            
            if [[ "$found_backups" == false ]]; then
                print_warning "No backups found"
            fi
        else
            print_warning "No backups directory found at ${HOME}/.dotbackups"
        fi
        return 0
    fi
    
    # Check for compressed backup first
    local backup_archive="${HOME}/.dotbackups/${backup_name}.tar.gz"
    local backup_dir="${HOME}/.dotbackups/${backup_name}"
    local restore_temp_dir=""
    
    if [[ -f "$backup_archive" ]]; then
        print_info "Found compressed backup: $backup_name"
        
        if ! confirm "Restore from backup '${backup_name}'?" "n"; then
            print_warning "Restore cancelled"
            return 0
        fi
        
        # Extract to temporary directory
        restore_temp_dir=$(mktemp -d -t DOT_restore_XXXXXX)
        print_info "Extracting backup..."
        
        if ! tar -xzf "$backup_archive" -C "$restore_temp_dir"; then
            print_error "Failed to extract backup"
            rm -rf "$restore_temp_dir"
            return 1
        fi
        
        backup_dir="$restore_temp_dir/$backup_name"
    elif [[ -d "$backup_dir" ]]; then
        print_info "Found uncompressed backup: $backup_name"
        
        if ! confirm "Restore from backup '${backup_name}'?" "n"; then
            print_warning "Restore cancelled"
            return 0
        fi
    else
        print_error "Backup '${backup_name}' not found"
        print_info "Run '${SCRIPT_NAME} backup restore' to see available backups"
        return 1
    fi
    
    print_info "Restoring files..."
    local count=0
    while IFS= read -r -d '' file; do
        local relative_path="${file#"${backup_dir}"/}"
        local target_path="${HOME}/${relative_path}"
        
        mkdir -p "$(dirname "$target_path")"
        cp -P "$file" "$target_path"
        ((count++))
    done < <(find "$backup_dir" -type f -print0)
    
    print_success "Restored $count files from backup"
    
    # Manual cleanup
    if [[ -n "$restore_temp_dir" ]]; then
        rm -rf "$restore_temp_dir"
    fi
}

cmd_backup_list() {
    print_header "Listing available backups"
    
    if [[ -d "${HOME}/.dotbackups" ]]; then
        local found_backups=false
        
        # List compressed backups
        for backup in "${HOME}/.dotbackups"/*.tar.gz; do
            if [[ -f "$backup" ]]; then
                local name
                name=$(basename "$backup" .tar.gz)
                local size
                size=$(du -h "$backup" | cut -f1)
                local date
                date=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$backup" 2>/dev/null || stat -c "%y" "$backup" 2>/dev/null | cut -d' ' -f1,2 | cut -d'.' -f1)
                echo "  - $name (${size}, $date)"
                found_backups=true
            fi
        done
        
        # List uncompressed backups (legacy)
        for backup in "${HOME}/.dotbackups"/*; do
            if [[ -d "$backup" ]]; then
                local name
                name=$(basename "$backup")
                echo "  - $name (uncompressed, legacy)"
                found_backups=true
            fi
        done
        
        if [[ "$found_backups" == false ]]; then
            print_warning "No backups found"
        fi
    else
        print_warning "No backups directory found"
    fi
}

cmd_backup_clean() {
    print_header "Cleaning up old backups"
    
    if [[ ! -d "${HOME}/.dotbackups" ]]; then
        print_info "No backups directory found at ${HOME}/.dotbackups"
        return 0
    fi
    
    local old_backups=()
    local cutoff_date
    cutoff_date=$(date -d "30 days ago" +%Y%m%d 2>/dev/null || date -v-30d +%Y%m%d 2>/dev/null)
    
    # Find old compressed backups
    for backup in "${HOME}/.dotbackups"/*.tar.gz; do
        if [[ -f "$backup" ]]; then
            local name
            name=$(basename "$backup" .tar.gz)
            if [[ "$name" =~ backup-([0-9]{8}) ]]; then
                local backup_date="${BASH_REMATCH[1]}"
                if [[ "$backup_date" < "$cutoff_date" ]]; then
                    old_backups+=("$backup")
                fi
            fi
        fi
    done
    
    if [[ ${#old_backups[@]} -eq 0 ]]; then
        print_success "No old backups found (older than 30 days)"
        return 0
    fi
    
    print_warning "Found ${#old_backups[@]} old backups:"
    for backup in "${old_backups[@]}"; do
        local size
        size=$(du -h "$backup" | cut -f1)
        echo "  - $(basename "$backup") (${size})"
    done
    
    if confirm "Delete these old backups?" "n"; then
        for backup in "${old_backups[@]}"; do
            rm "$backup"
            print_success "Deleted $(basename "$backup")"
        done
    fi
}

cmd_backup_compress() {
    print_header "Compressing legacy backups"
    
    if [[ ! -d "${HOME}/.dotbackups" ]]; then
        print_info "No backups directory found at ${HOME}/.dotbackups"
        return 0
    fi
    
    local legacy_backups=()
    for backup in "${HOME}/.dotbackups"/*; do
        if [[ -d "$backup" ]]; then
            legacy_backups+=("$backup")
        fi
    done
    
    if [[ ${#legacy_backups[@]} -eq 0 ]]; then
        print_success "No legacy backups found"
        return 0
    fi
    
    print_info "Found ${#legacy_backups[@]} uncompressed backups"
    
    for backup_dir in "${legacy_backups[@]}"; do
        local backup_name
        backup_name=$(basename "$backup_dir")
        local backup_archive="${backup_dir}.tar.gz"
        
        print_info "Compressing $backup_name..."
        
        if tar -czf "$backup_archive" -C "${HOME}/.dotbackups" "$backup_name"; then
            local original_size
            local compressed_size
            original_size=$(du -sh "$backup_dir" | cut -f1)
            compressed_size=$(du -sh "$backup_archive" | cut -f1)
            
            print_success "Compressed $backup_name: $original_size → $compressed_size"
            
            if confirm "Delete original uncompressed backup?" "y"; then
                rm -rf "$backup_dir"
            fi
        else
            print_error "Failed to compress $backup_name"
        fi
    done
}

cmd_backup_delete() {
    local backup_name="$1"
    if [[ -z "$backup_name" ]]; then
        print_error "Backup name required for delete action"
        print_info "Usage: ${SCRIPT_NAME} backup delete <backup-name>"
        return 1
    fi
    
    print_header "Deleting backup: $backup_name"
    
    local backup_archive="${HOME}/.dotbackups/${backup_name}.tar.gz"
    local backup_dir="${HOME}/.dotbackups/${backup_name}"
    
    if [[ -f "$backup_archive" ]]; then
        if confirm "Delete compressed backup '${backup_name}'?" "n"; then
            rm "$backup_archive"
            print_success "Deleted backup: $backup_name"
        fi
    elif [[ -d "$backup_dir" ]]; then
        if confirm "Delete uncompressed backup '${backup_name}'?" "n"; then
            rm -rf "$backup_dir"
            print_success "Deleted backup: $backup_name"
        fi
    else
        print_error "Backup '$backup_name' not found"
        return 1
    fi
}

cmd_backup_help() {
    echo -e "${BOLD}${SCRIPT_NAME} backup${RESET} - Backup management commands"
    echo ""
    
    echo -e "${BOLD}USAGE:${RESET}"
    echo "    ${SCRIPT_NAME} backup [SUBCOMMAND] [OPTIONS]"
    echo ""
    
    echo -e "${BOLD}SUBCOMMANDS:${RESET}"
    echo "    create [NAME]       Create compressed backup of current configuration (default)"
    echo "    restore [NAME]      Restore configuration from backup or list available backups"
    echo "    list                List all backups with details"
    echo "    clean               Remove backups older than 30 days"
    echo "    compress            Compress legacy uncompressed backups"
    echo "    delete NAME         Delete specific backup"
    echo "    help                Show this help message"
    echo ""
    
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "    ${SCRIPT_NAME} backup                    # Create timestamped backup"
    echo "    ${SCRIPT_NAME} backup create mybackup    # Create named backup"
    echo "    ${SCRIPT_NAME} backup mybackup           # Create named backup (shorthand)"
    echo "    ${SCRIPT_NAME} backup restore            # List available backups"
    echo "    ${SCRIPT_NAME} backup restore mybackup   # Restore specific backup"
    echo "    ${SCRIPT_NAME} backup list               # List all backups with details"
    echo "    ${SCRIPT_NAME} backup clean              # Remove old backups"
    echo "    ${SCRIPT_NAME} backup compress           # Compress legacy backups"
    echo "    ${SCRIPT_NAME} backup delete mybackup    # Delete specific backup"
    echo ""
    
    echo -e "${BOLD}NOTES:${RESET}"
    echo "    - Backups are automatically compressed using gzip for space efficiency"
    echo "    - Legacy uncompressed backups are still supported"
    echo "    - Clean command removes backups older than 30 days"
    echo "    - All operations require confirmation for destructive actions"
    echo ""
}

cmd_link() {
    print_header "Creating symlink for dot command"
    
    local target_dir="/usr/local/bin"
    local link_path="${target_dir}/dot"
    
    # Check if we can write to target directory
    if [[ ! -w "$target_dir" ]]; then
        print_info "Need sudo access to create symlink in ${target_dir}"
        target_dir="${HOME}/.local/bin"
        link_path="${target_dir}/dot"
        mkdir -p "$target_dir"
        print_info "Using ${target_dir} instead"
    fi
    
    # Remove existing link if present
    if [[ -L "$link_path" ]]; then
        rm "$link_path"
    fi
    
    # Create symlink
    if ln -s "${DOTFILES_DIR}/dot" "$link_path"; then
        print_success "Created symlink at ${link_path}"
        print_info "Make sure ${target_dir} is in your PATH"
    else
        print_error "Failed to create symlink"
        return 1
    fi
}

cmd_unlink() {
    print_header "Removing dot symlink"
    
    local paths=(
        "/usr/local/bin/dot"
        "${HOME}/.local/bin/dot"
        "/usr/local/bin/dotfiles"  # Legacy name
        "${HOME}/.local/bin/dotfiles"  # Legacy name
    )
    
    local found=false
    for link_path in "${paths[@]}"; do
        if [[ -L "$link_path" ]]; then
            if rm "$link_path"; then
                print_success "Removed symlink at ${link_path}"
                found=true
            else
                print_error "Failed to remove symlink at ${link_path}"
            fi
        fi
    done
    
    if [[ "$found" == false ]]; then
        print_warning "No dot symlink found"
    fi
}

cmd_stow() {
    print_header "Stowing dotfiles"
    
    if ! command_exists stow; then
        print_error "GNU Stow is not installed"
        print_info "Install it first: brew install stow"
        return 1
    fi
    
    print_info "Creating symlinks for dotfiles..."
    
    if stow -R -v -d "${DOTFILES_DIR}" -t "${HOME}" home; then
        print_success "Dotfiles stowed successfully"
        print_info "Configuration files are now symlinked to your home directory"
    else
        print_error "Failed to stow dotfiles"
        print_info "Check for conflicting files in your home directory"
        return 1
    fi
}

cmd_edit() {
    print_header "Opening dotfiles in editor"
    
    local editor="${EDITOR:-nvim}"
    
    if command_exists "$editor"; then
        exec "$editor" "$DOTFILES_DIR"
    else
        print_error "Editor '$editor' not found"
        print_info "Set EDITOR environment variable to specify your preferred editor"
        return 1
    fi
}

cmd_completions() {
    print_header "Generating Fish shell completions"
    
    local completions_dir="${HOME_DIR}/.config/fish/completions"
    local completions_file="${completions_dir}/dot.fish"
    
    # Check if Fish is installed
    if ! command_exists fish; then
        print_error "Fish shell is not installed"
        print_info "Install Fish shell first: brew install fish"
        return 1
    fi
    
    # Create completions directory if it doesn't exist
    if [[ ! -d "$completions_dir" ]]; then
        print_info "Creating Fish completions directory..."
        mkdir -p "$completions_dir"
    fi
    
    print_info "Generating completions file..."
    
    # Generate Fish completions
    cat > "$completions_file" << 'EOF'
# Fish shell completions for dot command
# Auto-generated by dot completions command

# Main command completions
complete -c dot -f

# Commands
complete -c dot -n "__fish_use_subcommand" -a "init" -d "Initialize and install dotfiles"
complete -c dot -n "__fish_use_subcommand" -a "update" -d "Update dotfiles and packages"
complete -c dot -n "__fish_use_subcommand" -a "doctor" -d "Run diagnostics and check installation"
complete -c dot -n "__fish_use_subcommand" -a "package" -d "Package management commands"
complete -c dot -n "__fish_use_subcommand" -a "check-packages" -d "Check which packages are installed/missing"
complete -c dot -n "__fish_use_subcommand" -a "retry-failed" -d "Retry failed package installations"
complete -c dot -n "__fish_use_subcommand" -a "summary" -d "Summarize recent git commits using Claude Code"
complete -c dot -n "__fish_use_subcommand" -a "benchmark-shell" -d "Benchmark Fish shell startup performance"
complete -c dot -n "__fish_use_subcommand" -a "gen-ssh-key" -d "Generate SSH key for GitHub/GitLab with email"
complete -c dot -n "__fish_use_subcommand" -a "stow" -d "Create symlinks for dotfiles using GNU Stow"
complete -c dot -n "__fish_use_subcommand" -a "backup" -d "Backup management commands"
complete -c dot -n "__fish_use_subcommand" -a "completions" -d "Generate Fish shell completions"
complete -c dot -n "__fish_use_subcommand" -a "link" -d "Install dot command globally (create symlink in PATH)"
complete -c dot -n "__fish_use_subcommand" -a "unlink" -d "Uninstall global dot command (remove symlink)"
complete -c dot -n "__fish_use_subcommand" -a "edit" -d "Open dotfiles in editor"
complete -c dot -n "__fish_use_subcommand" -a "help" -d "Show help message"

# Global options
complete -c dot -n "__fish_use_subcommand" -l "skip-ssh" -d "Skip SSH key generation"
complete -c dot -n "__fish_use_subcommand" -l "skip-font" -d "Skip font installation"
complete -c dot -n "__fish_use_subcommand" -l "version" -d "Show version information"
complete -c dot -n "__fish_use_subcommand" -s "h" -l "help" -d "Show help message"

# Package subcommands
complete -c dot -n "__fish_seen_subcommand_from package" -n "not __fish_seen_subcommand_from add remove update list help" -a "add" -d "Add package to bundle and install it"
complete -c dot -n "__fish_seen_subcommand_from package" -n "not __fish_seen_subcommand_from add remove update list help" -a "remove" -d "Remove package from bundle and optionally uninstall"
complete -c dot -n "__fish_seen_subcommand_from package" -n "not __fish_seen_subcommand_from add remove update list help" -a "update" -d "Update packages"
complete -c dot -n "__fish_seen_subcommand_from package" -n "not __fish_seen_subcommand_from add remove update list help" -a "list" -d "List packages in bundle files"
complete -c dot -n "__fish_seen_subcommand_from package" -n "not __fish_seen_subcommand_from add remove update list help" -a "help" -d "Show package help"

# Package add completions
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from add" -n "not __fish_seen_subcommand_from brew cask" -a "brew" -d "Brew formula"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from add" -n "not __fish_seen_subcommand_from brew cask" -a "cask" -d "Brew cask"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from add" -a "base" -d "Add to base bundle"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from add" -a "work" -d "Add to work bundle"

# Package remove/update completions
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from remove" -a "base" -d "Remove from base bundle only"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from remove" -a "work" -d "Remove from work bundle only"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from remove" -a "auto" -d "Remove from any bundle"

complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from update" -a "all" -d "Update all packages"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from update" -a "base" -d "Update base bundle packages only"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from update" -a "work" -d "Update work bundle packages only"

# Package list completions
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from list" -a "all" -d "List all packages"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from list" -a "base" -d "List base packages only"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from list" -a "work" -d "List work packages only"

# Backup subcommands
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "create" -d "Create compressed backup"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "restore" -d "Restore configuration from backup"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "list" -d "List all backups with details"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "clean" -d "Remove backups older than 30 days"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "compress" -d "Compress legacy uncompressed backups"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "delete" -d "Delete specific backup"
complete -c dot -n "__fish_seen_subcommand_from backup" -n "not __fish_seen_subcommand_from create restore list clean compress delete help" -a "help" -d "Show backup help"

# Summary command options
complete -c dot -n "__fish_seen_subcommand_from summary" -s "n" -l "number" -d "Number of commits to summarize" -xa "1 2 3 5 10"
complete -c dot -n "__fish_seen_subcommand_from summary" -s "d" -l "diff" -d "Include diff in analysis"
complete -c dot -n "__fish_seen_subcommand_from summary" -s "v" -l "verbose" -d "Show detailed commit info"
complete -c dot -n "__fish_seen_subcommand_from summary" -s "h" -l "help" -d "Show summary help"

# Benchmark-shell command options
complete -c dot -n "__fish_seen_subcommand_from benchmark-shell" -s "r" -l "runs" -d "Number of benchmark runs" -xa "5 10 15 20 25 30"
complete -c dot -n "__fish_seen_subcommand_from benchmark-shell" -s "v" -l "verbose" -d "Show detailed timing for each run"
complete -c dot -n "__fish_seen_subcommand_from benchmark-shell" -s "h" -l "help" -d "Show benchmark-shell help"

# Gen-ssh-key command options
complete -c dot -n "__fish_seen_subcommand_from gen-ssh-key" -s "h" -l "help" -d "Show gen-ssh-key help"

# Dynamic completions for installed packages (when removing or updating)
function __dot_installed_packages
    if command -q brew
        brew list --formula 2>/dev/null | head -20
        brew list --cask 2>/dev/null | head -20
    end
end

complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from remove" -xa "(__dot_installed_packages)"
complete -c dot -n "__fish_seen_subcommand_from package; and __fish_seen_subcommand_from update" -xa "(__dot_installed_packages)"

# Dynamic completions for available backups (when restoring or deleting)
function __dot_available_backups
    if test -d ~/.dotbackups
        for backup in ~/.dotbackups/*.tar.gz
            if test -f "$backup"
                basename "$backup" .tar.gz
            end
        end
        for backup in ~/.dotbackups/*
            if test -d "$backup"
                basename "$backup"
            end
        end
    end
end

complete -c dot -n "__fish_seen_subcommand_from backup; and __fish_seen_subcommand_from restore" -xa "(__dot_available_backups)"
complete -c dot -n "__fish_seen_subcommand_from backup; and __fish_seen_subcommand_from delete" -xa "(__dot_available_backups)"
EOF

    if [[ -f "$completions_file" ]]; then
        print_success "Fish completions generated at ${completions_file}"
        print_info "Completions will be available in new Fish shell sessions"
        print_info "To reload completions in current session, run: source ${completions_file}"
        
        # Check if completions are working
        if command_exists fish; then
            print_info "Testing completions..."
            if fish -c "complete -C 'dot '" >/dev/null 2>&1; then
                print_success "Completions are working correctly"
            else
                print_warning "Completions may need a shell restart to work properly"
            fi
        fi
    else
        print_error "Failed to generate completions file"
        return 1
    fi
}

cmd_benchmark_shell() {
    print_header "Benchmarking Fish shell startup performance"
    
    # Check if Fish is installed
    if ! command_exists fish; then
        print_error "Fish shell is not installed"
        print_info "Install Fish shell first: brew install fish"
        return 1
    fi
    
    # Parse options
    local runs=10
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -r|--runs)
                runs="$2"
                shift 2
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} benchmark-shell [OPTIONS]

${BOLD}OPTIONS:${RESET}
    -r, --runs NUM      Number of benchmark runs (default: 10)
    -v, --verbose       Show detailed timing for each run
    -h, --help          Show this help

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} benchmark-shell              # Run 10 benchmarks
    ${SCRIPT_NAME} benchmark-shell -r 20        # Run 20 benchmarks
    ${SCRIPT_NAME} benchmark-shell -v           # Show verbose output

EOF
                return 0
                ;;
            *)
                print_error "Unknown option: $1"
                print_info "Run '${SCRIPT_NAME} benchmark-shell --help' for usage"
                return 1
                ;;
        esac
    done
    
    # Validate number of runs
    if ! [[ "$runs" =~ ^[0-9]+$ ]] || [[ "$runs" -lt 1 ]] || [[ "$runs" -gt 100 ]]; then
        print_error "Number of runs must be between 1 and 100"
        return 1
    fi
    
    print_info "Running $runs Fish shell startup benchmarks..."
    
    # Create temporary script that exits immediately
    local temp_script
    temp_script=$(mktemp -t DOT_fish_benchmark_XXXXXX.fish)
    # Use RETURN trap instead of EXIT to avoid conflicts with other functions
    trap 'test -n "${temp_script:-}" && rm -f "$temp_script"' RETURN
    echo "exit 0" > "$temp_script"
    
    # Array to store timing results
    local times=()
    local total_time=0
    
    # Run benchmarks using a more sophisticated approach
    for i in $(seq 1 "$runs"); do
        if [[ "$verbose" == true ]]; then
            print_info "Run $i/$runs..."
        fi
        
        # Use python for high-precision timing if available, otherwise use perl
        local elapsed
        if command -v python3 >/dev/null 2>&1; then
            elapsed=$(python3 -c "
import time
import subprocess
import sys
start = time.time()
try:
    subprocess.run(['fish', '$temp_script'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
    end = time.time()
    print(f'{end - start:.3f}')
except:
    print('0.001')
")
        elif command -v perl >/dev/null 2>&1; then
            elapsed=$(perl -e "
use Time::HiRes 'time';
my \$start = time();
system('fish', '$temp_script', '>/dev/null', '2>&1');
my \$end = time();
printf '%.3f', \$end - \$start;
")
        else
            # Fallback to basic approach
            SECONDS=0
            fish "$temp_script" >/dev/null 2>&1
            elapsed="$SECONDS"
            if [[ "$elapsed" == "0" ]]; then
                elapsed="0.001"
            fi
        fi
        
        # Ensure elapsed is a valid number
        if [[ -z "$elapsed" ]] || ! [[ "$elapsed" =~ ^[0-9]*\.?[0-9]+$ ]]; then
            elapsed="0.001"
        fi
        
        times+=("$elapsed")
        if command -v bc >/dev/null 2>&1; then
            total_time=$(echo "$total_time + $elapsed" | bc -l)
        else
            total_time=$(echo "$total_time $elapsed" | awk '{print $1 + $2}')
        fi
        
        if [[ "$verbose" == true ]]; then
            printf "  Run %2d: %.3f seconds\n" "$i" "$elapsed"
        fi
    done
    
    # Calculate statistics
    local avg_time
    if command -v bc >/dev/null 2>&1; then
        avg_time=$(echo "scale=3; $total_time / $runs" | bc -l)
    else
        avg_time=$(echo "$total_time $runs" | awk '{printf "%.3f", $1/$2}')
    fi
    
    # Find min and max times
    local min_time="${times[0]}"
    local max_time="${times[0]}"
    
    for time in "${times[@]}"; do
        if command -v bc >/dev/null 2>&1; then
            if (( $(echo "$time < $min_time" | bc -l) )); then
                min_time="$time"
            fi
            if (( $(echo "$time > $max_time" | bc -l) )); then
                max_time="$time"
            fi
        else
            # Fallback for systems without bc
            if [[ $(echo "$time $min_time" | awk '{print ($1 < $2)}') == 1 ]]; then
                min_time="$time"
            fi
            if [[ $(echo "$time $max_time" | awk '{print ($1 > $2)}') == 1 ]]; then
                max_time="$time"
            fi
        fi
    done
    
    # Generate custom report
    print_header "Fish Shell Startup Benchmark Results"
    echo ""
    echo -e "${BOLD}Configuration:${RESET}"
    echo "  Shell: $(fish --version)"
    echo "  Runs: $runs"
    echo "  Test: Empty script execution"
    echo ""
    
    echo -e "${BOLD}Performance Results:${RESET}"
    printf "  Average time: ${GREEN}%.3f${RESET} seconds\n" "$avg_time"
    printf "  Fastest time: ${GREEN}%.3f${RESET} seconds\n" "$min_time"
    printf "  Slowest time: ${YELLOW}%.3f${RESET} seconds\n" "$max_time"
    
    if command -v bc >/dev/null 2>&1; then
        local range
        range=$(echo "scale=3; $max_time - $min_time" | bc -l)
        printf "  Time range:   ${CYAN}%.3f${RESET} seconds\n" "$range"
    fi
    
    echo ""
    echo -e "${BOLD}Performance Assessment:${RESET}"
    
    # Performance thresholds (in seconds)
    local excellent=0.050
    local good=0.100
    local fair=0.200
    
    if command -v bc >/dev/null 2>&1; then
        if (( $(echo "$avg_time <= $excellent" | bc -l) )); then
            print_success "Excellent startup performance! (≤50ms)"
        elif (( $(echo "$avg_time <= $good" | bc -l) )); then
            print_success "Good startup performance (≤100ms)"
        elif (( $(echo "$avg_time <= $fair" | bc -l) )); then
            print_warning "Fair startup performance (≤200ms)"
        else
            print_warning "Slow startup performance (>200ms)"
            echo ""
            print_info "Tips to improve Fish shell startup time:"
            print_info "  - Review Fish config.fish for expensive operations"
            print_info "  - Consider lazy-loading plugins and functions"
            print_info "  - Check for slow network operations in startup scripts"
            print_info "  - Use 'fish --profile' to identify bottlenecks"
        fi
    else
        # Fallback assessment without bc
        if [[ $(echo "$avg_time 0.050" | awk '{print ($1 <= $2)}') == 1 ]]; then
            print_success "Excellent startup performance! (≤50ms)"
        elif [[ $(echo "$avg_time 0.100" | awk '{print ($1 <= $2)}') == 1 ]]; then
            print_success "Good startup performance (≤100ms)"
        elif [[ $(echo "$avg_time 0.200" | awk '{print ($1 <= $2)}') == 1 ]]; then
            print_warning "Fair startup performance (≤200ms)"
        else
            print_warning "Slow startup performance (>200ms)"
        fi
    fi
    
    echo ""
    print_info "To profile Fish startup in detail, run: fish --profile"
    print_info "Fish config location: ~/.config/fish/config.fish"
}

cmd_summary() {
    print_header "Summarizing recent changes"
    
    # Save current shell options for restoration
    local _saved_opts="$-"
    
    # Check if Claude Code is available
    if ! command_exists claude; then
        print_error "Claude Code is not installed"
        print_info "Install it with: bun install -g @anthropic-ai/claude-code (or npm install -g @anthropic-ai/claude-code)"
        return 1
    fi
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Not in a git repository"
        return 1
    fi
    
    # Parse options
    local num_commits=3
    local include_diff=false
    local verbose=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -n|--number)
                num_commits="$2"
                shift 2
                ;;
            -d|--diff)
                include_diff=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -h|--help)
                cat << EOF
${BOLD}USAGE:${RESET}
    ${SCRIPT_NAME} summary [OPTIONS]

${BOLD}OPTIONS:${RESET}
    -n, --number NUM    Number of commits to summarize (default: 3)
    -d, --diff          Include diff in analysis for more detailed summary
    -v, --verbose       Show detailed commit info before summary
    -h, --help          Show this help

${BOLD}EXAMPLES:${RESET}
    ${SCRIPT_NAME} summary              # Summarize last 3 commits
    ${SCRIPT_NAME} summary -n 5         # Summarize last 5 commits  
    ${SCRIPT_NAME} summary -d           # Include diffs for detailed analysis
    ${SCRIPT_NAME} summary -v -n 2      # Verbose mode, 2 commits

EOF
                return 0
                ;;
            *)
                print_error "Unknown option: $1"
                print_info "Run '${SCRIPT_NAME} summary --help' for usage"
                return 1
                ;;
        esac
    done
    
    # Validate number of commits
    if ! [[ "$num_commits" =~ ^[0-9]+$ ]] || [[ "$num_commits" -lt 1 ]] || [[ "$num_commits" -gt 20 ]]; then
        print_error "Number of commits must be between 1 and 20"
        return 1
    fi
    
    print_info "Analyzing last $num_commits commit(s)..."
    
    # Get commit information
    local git_log_format="%H|%an|%ae|%ad|%s"
    local commits_info
    commits_info=$(git log --format="$git_log_format" --date=short -n "$num_commits")
    
    if [[ -z "$commits_info" ]]; then
        print_warning "No commits found"
        return 0
    fi
    
    # Show verbose info if requested
    if [[ "$verbose" == true ]]; then
        print_info "Recent commits:"
        echo "$commits_info" | while IFS='|' read -r hash author _ date subject; do
            local short_hash="${hash:0:8}"
            echo "  $short_hash - $subject ($author, $date)"
        done
        echo ""
    fi
    
    # Build prompt for Claude
    local claude_prompt="You are a technical writer. Provide ONLY a concise 2-3 paragraph summary of these Git commits. Do NOT ask questions or provide additional commentary. Focus on:
1. What changes were made (features, fixes, improvements)
2. Overall patterns or themes in the development
3. Any notable technical decisions or architectural changes

Here are the commits (most recent first):

"
    
    # Add commit details to prompt
    local commit_count=0
    local temp_commits_file
    temp_commits_file=$(mktemp -t DOT_commits_XXXXXX)
    echo "$commits_info" > "$temp_commits_file"
    
    # Process commits with better error handling
    set +e  # Temporarily disable exit on error for this section
    while IFS='|' read -r hash author _ date subject; do
        ((commit_count++))
        local short_hash="${hash:0:8}"
        claude_prompt+="Commit $commit_count ($short_hash, $date):
Subject: $subject
Author: $author
"
        
        # Add diff if requested
        if [[ "$include_diff" == true ]]; then
            local diff_output
            diff_output=$(git show --format="" --name-status "$hash" 2>/dev/null || true)
            if [[ -n "$diff_output" ]]; then
                claude_prompt+="Files changed:
$diff_output

"
            fi
        fi
        
        claude_prompt+="
"
    done < "$temp_commits_file"
    
    # Clean up temp file
    rm -f "$temp_commits_file"
    
    # Add instructions
    claude_prompt+="

INSTRUCTIONS: Respond with ONLY a concise 2-3 paragraph technical summary. Do not ask questions or provide additional commentary."
    
    # Create temporary file for the prompt
    local temp_file
    temp_file=$(mktemp -t DOT_prompt_XXXXXX)
    echo "$claude_prompt" > "$temp_file"
    
    print_info "Generating summary with Claude Code..."
    
    # Call Claude Code with explicit error handling
    local claude_output=""
    local claude_error=""
    local exit_code=0
    
    # Temporarily disable set -e to capture the exit code properly
    set +e
    claude_output=$(claude --model sonnet --print < "$temp_file" 2>&1)
    exit_code=$?
    # Restore original shell options
    set -"$_saved_opts"
    
    if [[ $exit_code -eq 0 && -n "$claude_output" ]]; then
        print_header "Summary of Recent Changes"
        echo ""
        echo "$claude_output"
        echo ""
    else
        print_error "Failed to generate summary with Claude Code (exit code: $exit_code)"
        if [[ -n "$claude_output" ]]; then
            claude_error="$claude_output"
        else
            claude_error="No output received from Claude Code"
        fi
    fi
    
    # Handle errors if any occurred
    if [[ -n "${claude_error:-}" ]]; then
        
        # Check if it's an authentication issue
        if echo "$claude_output" | grep -q -i "auth\|login\|api"; then
            print_info "Claude Code needs authentication. Run: claude auth login"
        elif echo "$claude_output" | grep -q -i "network\|connection"; then
            print_info "Network connection issue. Check your internet connection"
        else
            print_info "Claude Code error: $claude_output"
            print_info "Try running: claude --version to verify installation"
        fi
        
        return 1
    fi
    
    # Clean up temp file
    rm -f "$temp_file"
    
    # Show git log reference
    print_info "For detailed commit history, run: git log --oneline -n $num_commits"
}

cmd_retry_failed() {
    print_header "Retrying failed package installations"
    
    # Find the most recent failed packages file
    local failed_file
    failed_file=$(find "${PACKAGES_DIR}" -name "failed_packages_*.txt" -type f 2>/dev/null | sort -r | head -1)
    
    if [[ -z "$failed_file" || ! -f "$failed_file" ]]; then
        print_info "No failed packages file found"
        return 0
    fi
    
    print_info "Found failed packages file: $failed_file"
    print_info "Attempting to retry installation..."
    
    local retry_count=0
    local success_count=0
    
    while IFS= read -r package_info; do
        ((retry_count++))
        
        if [[ "$package_info" =~ ^brew:(.+)$ ]]; then
            local package="${BASH_REMATCH[1]}"
            print_info "Retrying brew package: $package"
            if brew install "$package" 2>/dev/null; then
                print_success "Successfully installed: $package"
                ((success_count++))
            else
                print_warning "Still failing: $package"
            fi
        elif [[ "$package_info" =~ ^cask:(.+)$ ]]; then
            local package="${BASH_REMATCH[1]}"
            print_info "Retrying cask: $package"
            if brew install --cask "$package" 2>/dev/null; then
                print_success "Successfully installed: $package"
                ((success_count++))
            else
                print_warning "Still failing: $package"
            fi
        fi
    done < "$failed_file"
    
    print_info "Retry complete: $success_count/$retry_count packages installed"
    
    if [[ $success_count -eq $retry_count ]]; then
        print_success "All failed packages now installed!"
        rm "$failed_file"
    fi
}

cmd_check_packages() {
    print_header "Checking installed packages"
    
    local missing_brew=()
    local missing_cask=()
    local installed_brew=()
    local installed_cask=()
    
    # Get lists of installed packages once to avoid repeated calls
    local installed_formulas
    local installed_casks
    installed_formulas=$(brew list --formula 2>/dev/null || true)
    installed_casks=$(brew list --cask 2>/dev/null || true)
    
    # Check base packages
    if [[ -f "${PACKAGES_DIR}/bundle" ]]; then
        print_info "Checking base packages..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^brew "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    if echo "$installed_formulas" | grep -q "^${package}$"; then
                        installed_brew+=("$package")
                    else
                        missing_brew+=("$package")
                    fi
                fi
            elif [[ "$line" =~ ^cask[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^cask "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    if echo "$installed_casks" | grep -q "^${package}$"; then
                        installed_cask+=("$package")
                    else
                        missing_cask+=("$package")
                    fi
                fi
            fi
        done < "${PACKAGES_DIR}/bundle"
    fi
    
    # Check work packages
    if [[ -f "${PACKAGES_DIR}/bundle.work" ]]; then
        print_info "Checking work packages..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]] ]]; then
                local package
                package=$(echo "$line" | sed -n 's/^brew "\([^"]*\)".*/\1/p')
                if [[ -n "$package" ]]; then
                    if echo "$installed_formulas" | grep -q "^${package}$"; then
                        installed_brew+=("$package (work)")
                    else
                        missing_brew+=("$package (work)")
                    fi
                fi
            fi
        done < "${PACKAGES_DIR}/bundle.work"
    fi
    
    # Report results
    print_header "Package Status Report"
    
    echo -e "\n${BOLD}Installed Packages:${RESET}"
    print_success "Brew formulas: ${#installed_brew[@]}"
    print_success "Casks: ${#installed_cask[@]}"
    
    if [[ ${#missing_brew[@]} -gt 0 || ${#missing_cask[@]} -gt 0 ]]; then
        echo -e "\n${BOLD}Missing Packages:${RESET}"
        
        if [[ ${#missing_brew[@]} -gt 0 ]]; then
            print_warning "Missing brew formulas (${#missing_brew[@]}):"
            printf "  - %s\n" "${missing_brew[@]}"
        fi
        
        if [[ ${#missing_cask[@]} -gt 0 ]]; then
            print_warning "Missing casks (${#missing_cask[@]}):"
            printf "  - %s\n" "${missing_cask[@]}"
        fi
        
        echo ""
        print_info "Run '${SCRIPT_NAME} init' to install missing packages"
    else
        print_success "All packages are installed!"
    fi
}

cmd_package() {
    local subcommand="${1:-list}"
    shift || true
    
    case "$subcommand" in
        add)
            cmd_package_add "$@"
            ;;
        remove)
            cmd_package_remove "$@"
            ;;
        update)
            cmd_package_update "$@"
            ;;
        list)
            cmd_package_list "$@"
            ;;
        -h|--help|help)
            cmd_package_help
            ;;
        *)
            print_error "Unknown package subcommand: $subcommand"
            print_info "Run '${SCRIPT_NAME} package help' for usage"
            return 1
            ;;
    esac
}

cmd_package_add() {
    local package_name="$1"
    local package_type="${2:-auto}"
    local bundle_file="${3:-base}"
    
    if [[ -z "$package_name" ]]; then
        print_error "Package name required"
        print_info "Usage: ${SCRIPT_NAME} package add <package-name> [brew|cask] [base|work]"
        return 1
    fi
    
    # Determine bundle file
    local target_bundle
    if [[ "$bundle_file" == "work" ]]; then
        target_bundle="${PACKAGES_DIR}/bundle.work"
    else
        target_bundle="${PACKAGES_DIR}/bundle"
    fi
    
    # Auto-detect package type if not specified
    if [[ "$package_type" == "auto" ]]; then
        print_info "Detecting package type..."
        # Use brew info --json for more precise package detection
        if brew info --json=v2 --formula "$package_name" >/dev/null 2>&1; then
            package_type="brew"
        elif brew info --json=v2 --cask "$package_name" >/dev/null 2>&1; then
            package_type="cask"
        else
            print_warning "Package '$package_name' not found in either formulas or casks"
            print_info "Defaulting to brew formula. Use 'brew' or 'cask' to specify explicitly"
            package_type="brew"
        fi
    fi
    
    # Validate package type
    if [[ "$package_type" != "brew" && "$package_type" != "cask" ]]; then
        print_error "Package type must be 'brew' or 'cask'"
        return 1
    fi
    
    # Check if package already exists in bundle
    local package_line="${package_type} \"${package_name}\""
    if grep -q "^${package_line}$" "$target_bundle" 2>/dev/null; then
        print_warning "Package '$package_name' already exists in $(basename "$target_bundle")"
        return 0
    fi
    
    print_header "Adding $package_type package: $package_name"
    
    # Install the package first
    print_info "Installing package..."
    if [[ "$package_type" == "cask" ]]; then
        if brew install --cask "$package_name"; then
            print_success "Package installed successfully"
        else
            print_error "Failed to install package"
            return 1
        fi
    else
        if brew install "$package_name"; then
            print_success "Package installed successfully"
        else
            print_error "Failed to install package"
            return 1
        fi
    fi
    
    # Add to bundle file
    print_info "Adding to bundle file..."
    if [[ ! -f "$target_bundle" ]]; then
        print_warning "Bundle file doesn't exist, creating: $target_bundle"
        mkdir -p "$(dirname "$target_bundle")"
        touch "$target_bundle"
    fi
    
    # Find the right place to insert the package (keep them sorted)
    local temp_file
    temp_file=$(mktemp)
    local inserted=false
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        # If this is a package line of the same type and comes after our package alphabetically
        if [[ "$line" =~ ^${package_type}[[:space:]]+\"([^\"]+)\" ]] && [[ "$inserted" == false ]]; then
            local existing_package="${BASH_REMATCH[1]}"
            if [[ "$package_name" < "$existing_package" ]]; then
                echo "$package_line" >> "$temp_file"
                inserted=true
            fi
        fi
        echo "$line" >> "$temp_file"
    done < "$target_bundle"
    
    # If we haven't inserted yet, add at the end
    if [[ "$inserted" == false ]]; then
        echo "$package_line" >> "$temp_file"
    fi
    
    # Replace the original file
    mv "$temp_file" "$target_bundle"
    
    print_success "Added '$package_name' to $(basename "$target_bundle")"
    print_info "Package will be included in future installations"
}

cmd_package_remove() {
    local package_name="$1"
    local bundle_file="${2:-auto}"
    
    if [[ -z "$package_name" ]]; then
        print_error "Package name required"
        print_info "Usage: ${SCRIPT_NAME} package remove <package-name> [base|work|auto]"
        return 1
    fi
    
    print_header "Removing package: $package_name"
    
    # Determine which bundle files to check
    local bundle_files=()
    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
    else
        # Auto mode - check both
        bundle_files=("${PACKAGES_DIR}/bundle" "${PACKAGES_DIR}/bundle.work")
    fi
    
    local found=false
    local package_type=""
    
    # Find and remove from bundle files
    for target_bundle in "${bundle_files[@]}"; do
        if [[ ! -f "$target_bundle" ]]; then
            continue
        fi
        
        # Check if package exists
        if grep -q "^\\(brew\\|cask\\)[[:space:]]*\"${package_name}\"" "$target_bundle"; then
            found=true
            
            # Determine package type
            if grep -q "^brew[[:space:]]*\"${package_name}\"" "$target_bundle"; then
                package_type="formula"
            else
                package_type="cask"
            fi
            
            # Remove from bundle file
            print_info "Removing from $(basename "$target_bundle")..."
            local temp_file
            temp_file=$(mktemp)
            grep -v "^\\(brew\\|cask\\)[[:space:]]*\"${package_name}\"" "$target_bundle" > "$temp_file"
            mv "$temp_file" "$target_bundle"
            
            print_success "Removed '$package_name' from $(basename "$target_bundle")"
        fi
    done
    
    if [[ "$found" == false ]]; then
        print_warning "Package '$package_name' not found in any bundle files"
        return 0
    fi
    
    # Ask if user wants to uninstall the actual package
    if confirm "Uninstall '$package_name' from system?" "n"; then
        print_info "Uninstalling package..."
        if [[ "$package_type" == "cask" ]]; then
            if brew uninstall --cask "$package_name"; then
                print_success "Package uninstalled successfully"
            else
                print_warning "Failed to uninstall package (it may have dependencies)"
            fi
        else
            if brew uninstall "$package_name"; then
                print_success "Package uninstalled successfully"
            else
                print_warning "Failed to uninstall package (it may have dependencies)"
            fi
        fi
    else
        print_info "Package removed from bundle but left installed on system"
    fi
}

cmd_package_update() {
    local package_name="${1:-all}"
    local bundle_file="${2:-all}"
    
    print_header "Updating packages"
    
    # If updating a specific package
    if [[ "$package_name" != "all" ]]; then
        print_info "Updating specific package: $package_name"
        
        # Check if package is installed
        local is_formula=false
        local is_cask=false
        
        if brew list --formula | grep -q "^${package_name}$"; then
            is_formula=true
        elif brew list --cask | grep -q "^${package_name}$"; then
            is_cask=true  # Used in conditional logic below
        else
            print_error "Package '$package_name' is not installed"
            return 1
        fi
        
        # Update the specific package
        if [[ "$is_formula" == true ]]; then
            print_info "Updating brew formula: $package_name"
            if brew upgrade "$package_name"; then
                print_success "Updated $package_name successfully"
            else
                print_warning "Failed to update $package_name (may already be latest version)"
            fi
        elif [[ "$is_cask" == true ]]; then
            print_info "Updating cask: $package_name"
            if brew upgrade --cask "$package_name"; then
                print_success "Updated $package_name successfully"
            else
                print_warning "Failed to update $package_name (may already be latest version or not upgradeable)"
            fi
        fi
        return 0
    fi
    
    # Update all packages (default behavior)
    print_info "Updating Homebrew and all packages..."
    
    # Update Homebrew first
    print_info "Updating Homebrew..."
    if brew update; then
        print_success "Homebrew updated successfully"
    else
        print_error "Failed to update Homebrew"
        return 1
    fi
    
    # Determine which packages to update based on bundle filter
    local bundle_files=()
    local bundle_names=()
    
    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
        bundle_names=("work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
        bundle_names=("base")
    else
        # All mode - update everything installed, not just bundle packages
        print_info "Upgrading all installed packages..."
        
        # Upgrade all formulas
        print_info "Upgrading brew formulas..."
        if brew upgrade; then
            print_success "Brew formulas updated"
        else
            print_warning "Some brew formulas failed to update"
        fi
        
        # Upgrade all casks
        print_info "Upgrading casks..."
        if brew upgrade --cask; then
            print_success "Casks updated"
        else
            print_warning "Some casks failed to update"
        fi
        
        # Cleanup
        if confirm "Clean up old versions?" "y"; then
            print_info "Cleaning up old package versions..."
            brew cleanup
            print_success "Cleanup completed"
        fi
        
        return 0
    fi
    
    # Update packages from specific bundle(s)
    local updated_packages=()
    local failed_packages=()
    
    for i in "${!bundle_files[@]}"; do
        local target_bundle="${bundle_files[$i]}"
        local bundle_name="${bundle_names[$i]}"
        
        if [[ ! -f "$target_bundle" ]]; then
            print_warning "Bundle file not found: $(basename "$target_bundle")"
            continue
        fi
        
        print_info "Updating packages from ${bundle_name} bundle..."
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                
                # Check if package is installed
                if brew list --formula | grep -q "^${package}$"; then
                    print_info "Updating brew formula: $package"
                    if brew upgrade "$package" 2>/dev/null; then
                        updated_packages+=("$package (formula)")
                    else
                        # Package might already be up to date
                        print_info "$package is already up to date"
                    fi
                else
                    print_warning "Package $package not installed, skipping"
                fi
                
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                local package="${BASH_REMATCH[1]}"
                
                # Check if cask is installed
                if brew list --cask | grep -q "^${package}$"; then
                    print_info "Updating cask: $package"
                    if brew upgrade --cask "$package" 2>/dev/null; then
                        updated_packages+=("$package (cask)")
                    else
                        # Cask might already be up to date or not upgradeable
                        print_info "$package is already up to date or not upgradeable"
                    fi
                else
                    print_warning "Cask $package not installed, skipping"
                fi
            fi
        done < "$target_bundle"
    done
    
    # Report results
    if [[ ${#updated_packages[@]} -gt 0 ]]; then
        print_success "Updated ${#updated_packages[@]} packages:"
        printf "  - %s\n" "${updated_packages[@]}"
    else
        print_info "All packages are already up to date"
    fi
    
    if [[ ${#failed_packages[@]} -gt 0 ]]; then
        print_warning "Failed to update ${#failed_packages[@]} packages:"
        printf "  - %s\n" "${failed_packages[@]}"
    fi
    
    # Cleanup
    if confirm "Clean up old versions?" "y"; then
        print_info "Cleaning up old package versions..."
        brew cleanup
        print_success "Cleanup completed"
    fi
}

cmd_package_list() {
    local bundle_file="${1:-all}"
    
    print_header "Listing packages"
    
    # Determine which bundle files to list
    local bundle_files=()
    local bundle_names=()
    
    if [[ "$bundle_file" == "work" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle.work")
        bundle_names=("work")
    elif [[ "$bundle_file" == "base" ]]; then
        bundle_files=("${PACKAGES_DIR}/bundle")
        bundle_names=("base")
    else
        # All mode
        bundle_files=("${PACKAGES_DIR}/bundle" "${PACKAGES_DIR}/bundle.work")
        bundle_names=("base" "work")
    fi
    
    for i in "${!bundle_files[@]}"; do
        local target_bundle="${bundle_files[$i]}"
        local bundle_name="${bundle_names[$i]}"
        
        if [[ ! -f "$target_bundle" ]]; then
            if [[ "$bundle_file" != "all" ]]; then
                print_warning "Bundle file not found: $(basename "$target_bundle")"
            fi
            continue
        fi
        
        echo -e "\n${BOLD}${bundle_name^} packages ($(basename "$target_bundle")):${RESET}"
        
        local brew_packages=()
        local cask_packages=()
        
        while IFS= read -r line; do
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "${line// }" ]] && continue
            
            if [[ "$line" =~ ^brew[[:space:]]+\"([^\"]+)\" ]]; then
                brew_packages+=("${BASH_REMATCH[1]}")
            elif [[ "$line" =~ ^cask[[:space:]]+\"([^\"]+)\" ]]; then
                cask_packages+=("${BASH_REMATCH[1]}")
            fi
        done < "$target_bundle"
        
        if [[ ${#brew_packages[@]} -gt 0 ]]; then
            echo -e "  ${BOLD}Brew formulas (${#brew_packages[@]}):${RESET}"
            for package in "${brew_packages[@]}"; do
                if brew list --formula | grep -q "^${package}$"; then
                    print_success "    $package"
                else
                    print_error "    $package (not installed)"
                fi
            done
        fi
        
        if [[ ${#cask_packages[@]} -gt 0 ]]; then
            echo -e "  ${BOLD}Casks (${#cask_packages[@]}):${RESET}"
            for package in "${cask_packages[@]}"; do
                if brew list --cask | grep -q "^${package}$"; then
                    print_success "    $package"
                else
                    print_error "    $package (not installed)"
                fi
            done
        fi
        
        if [[ ${#brew_packages[@]} -eq 0 && ${#cask_packages[@]} -eq 0 ]]; then
            print_info "  No packages found"
        fi
    done
}

cmd_package_help() {
    echo -e "${BOLD}${SCRIPT_NAME} package${RESET} - Package management commands"
    echo ""
    
    echo -e "${BOLD}USAGE:${RESET}"
    echo "    ${SCRIPT_NAME} package [SUBCOMMAND] [OPTIONS]"
    echo ""
    
    echo -e "${BOLD}SUBCOMMANDS:${RESET}"
    echo "    add NAME [TYPE] [BUNDLE]   Add package to bundle and install it"
    echo "    remove NAME [BUNDLE]       Remove package from bundle and optionally uninstall"
    echo "    update [NAME] [BUNDLE]     Update packages (all packages by default)"
    echo "    list [BUNDLE]              List packages in bundle files (default)"
    echo "    help                       Show this help message"
    echo ""
    
    echo -e "${BOLD}PARAMETERS:${RESET}"
    echo "    NAME                       Package name (required for add/remove, optional for update)"
    echo "    TYPE                       Package type: 'brew' or 'cask' (auto-detected if not specified)"
    echo "    BUNDLE                     Bundle file: 'base', 'work', or 'all' (default varies by command)"
    echo ""
    
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "    ${SCRIPT_NAME} package list               # List all packages"
    echo "    ${SCRIPT_NAME} package list base          # List base packages only"
    echo "    ${SCRIPT_NAME} package list work          # List work packages only"
    echo "    ${SCRIPT_NAME} package add git            # Add git formula to base bundle"
    echo "    ${SCRIPT_NAME} package add docker cask    # Add docker cask to base bundle"
    echo "    ${SCRIPT_NAME} package add kubectl brew work  # Add kubectl to work bundle"
    echo "    ${SCRIPT_NAME} package remove git         # Remove git from any bundle"
    echo "    ${SCRIPT_NAME} package remove docker base # Remove docker from base bundle only"
    echo "    ${SCRIPT_NAME} package update             # Update all installed packages"
    echo "    ${SCRIPT_NAME} package update git         # Update specific package"
    echo "    ${SCRIPT_NAME} package update all base    # Update only base bundle packages"
    echo "    ${SCRIPT_NAME} package update all work    # Update only work bundle packages"
    echo ""
    
    echo -e "${BOLD}NOTES:${RESET}"
    echo "    - Package type is auto-detected if not specified"
    echo "    - Packages are kept sorted alphabetically within each type"
    echo "    - Adding a package installs it immediately and adds to bundle"
    echo "    - Removing a package removes from bundle and optionally uninstalls"
    echo "    - Updating without arguments updates all installed packages"
    echo "    - Update command includes Homebrew refresh and optional cleanup"
    echo "    - Work bundle (bundle.work) is for work-specific packages"
    echo "    - Base bundle (bundle) is for general-purpose packages"
    echo ""
}

cmd_help() {
    echo -e "${BOLD}${SCRIPT_NAME}${RESET} - Dotfiles management tool"
    echo "Version: ${VERSION}"
    echo ""
    
    echo -e "${BOLD}USAGE:${RESET}"
    echo "    ${SCRIPT_NAME} [OPTIONS] COMMAND [ARGS]"
    echo ""
    
    echo -e "${BOLD}COMMANDS:${RESET}"
    echo "    init                Initialize and install dotfiles"
    echo "    update              Update dotfiles and packages"
    echo "    doctor              Run diagnostics and check installation"
    echo "    package             Package management commands (add, remove, list)"
    echo "    check-packages      Check which packages are installed/missing"
    echo "    retry-failed        Retry failed package installations"
    echo "    summary             Summarize recent git commits using Claude Code"
    echo "    benchmark-shell     Benchmark Fish shell startup performance"
    echo "    gen-ssh-key         Generate SSH key for GitHub/GitLab with email"
    echo "    stow                Create symlinks for dotfiles using GNU Stow"
    echo "    backup              Backup management commands (create, restore, list, clean, etc.)"
    echo "    completions         Generate Fish shell completions"
    echo "    link                Install dot command globally (create symlink in PATH)"
    echo "    unlink              Uninstall global dot command (remove symlink)"
    echo "    edit                Open dotfiles in editor"
    echo "    help                Show this help message (default)"
    echo ""
    
    echo -e "${BOLD}OPTIONS:${RESET}"
    echo "    --skip-ssh      Skip SSH key generation"
    echo "    --skip-font     Skip font installation"
    echo "    --version       Show version information"
    echo "    -h, --help      Show this help message"
    echo ""
    
    echo -e "${BOLD}EXAMPLES:${RESET}"
    echo "    ${SCRIPT_NAME} init                      # Full initialization"
    echo "    ${SCRIPT_NAME} init --skip-ssh           # Initialize without SSH setup"
    echo "    ${SCRIPT_NAME} update                    # Update everything"
    echo "    ${SCRIPT_NAME} doctor                    # Check installation health"
    echo "    ${SCRIPT_NAME} package list              # List all packages"
    echo "    ${SCRIPT_NAME} package add git           # Add git package to base bundle"
    echo "    ${SCRIPT_NAME} package update            # Update all packages"
    echo "    ${SCRIPT_NAME} package remove docker     # Remove docker from bundles"
    echo "    ${SCRIPT_NAME} check-packages            # See package installation status"
    echo "    ${SCRIPT_NAME} retry-failed              # Retry any failed installations"
    echo "    ${SCRIPT_NAME} summary                   # Summarize last 3 commits with AI"
    echo "    ${SCRIPT_NAME} summary -n 5 -d           # Detailed summary of last 5 commits"
    echo "    ${SCRIPT_NAME} benchmark-shell           # Benchmark Fish shell startup time"
    echo "    ${SCRIPT_NAME} benchmark-shell -r 20 -v  # Run 20 benchmarks with verbose output"
    echo "    ${SCRIPT_NAME} gen-ssh-key               # Generate SSH key (prompts for email)"
    echo "    ${SCRIPT_NAME} gen-ssh-key user@github.com  # Generate SSH key with email"
    echo "    ${SCRIPT_NAME} stow                      # Create symlinks for dotfiles"
    echo "    ${SCRIPT_NAME} backup                    # Create timestamped compressed backup"
    echo "    ${SCRIPT_NAME} backup create mybackup    # Create named compressed backup"
    echo "    ${SCRIPT_NAME} backup restore            # List available backups"
    echo "    ${SCRIPT_NAME} backup restore mybackup   # Restore specific backup"
    echo "    ${SCRIPT_NAME} backup list               # List all backups with details"
    echo "    ${SCRIPT_NAME} backup clean              # Remove backups older than 30 days"
    echo "    ${SCRIPT_NAME} backup compress           # Compress legacy uncompressed backups"
    echo "    ${SCRIPT_NAME} backup delete foo         # Delete specific backup"
    echo "    ${SCRIPT_NAME} completions               # Generate Fish shell completions"
    echo "    ${SCRIPT_NAME} link                      # Install dot command globally in PATH"
    echo ""
    
    echo -e "${BOLD}CONFIGURATION:${RESET}"
    echo "    Dotfiles directory: ${DOTFILES_DIR}"
    echo "    Packages directory: ${PACKAGES_DIR}"
    echo "    Home directory:     ${HOME_DIR}"
    echo ""
    
    echo -e "${BOLD}NOTES:${RESET}"
    echo "    - Package installation is resilient to failures"
    echo "    - Failed packages are logged and can be retried later"
    echo "    - Backups are automatically compressed using gzip"
    echo "    - Legacy uncompressed backups are still supported"
    echo "    - SHA verification is disabled for better reliability"
    echo "    - Claude Code CLI installed globally via Bun/npm during init"
    echo "    - Doctor command checks all critical development tools"
    echo "    - Summary command uses AI to analyze and summarize git commits"
    echo ""
}

# Main function
main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --skip-ssh)
                export SKIP_SSH=true
                shift
                ;;
            --skip-font)
                export SKIP_FONT=true
                shift
                ;;
            --version)
                echo "${SCRIPT_NAME} version ${VERSION}"
                exit 0
                ;;
            -h|--help)
                cmd_help
                exit 0
                ;;
            *)
                break
                ;;
        esac
    done
    
    # Get command
    local cmd="${1:-help}"
    shift || true
    
    # Execute command
    case "$cmd" in
        init)
            cmd_init "$@"
            ;;
        update)
            cmd_update "$@"
            ;;
        doctor)
            cmd_doctor "$@"
            ;;
        package)
            cmd_package "$@"
            ;;
        check-packages)
            cmd_check_packages "$@"
            ;;
        retry-failed)
            cmd_retry_failed "$@"
            ;;
        summary)
            cmd_summary "$@"
            ;;
        benchmark-shell)
            cmd_benchmark_shell "$@"
            ;;
        gen-ssh-key)
            cmd_gen_ssh_key "$@"
            ;;
        stow)
            cmd_stow "$@"
            ;;
        backup)
            cmd_backup "$@"
            ;;
        completions)
            cmd_completions "$@"
            ;;
        link)
            cmd_link "$@"
            ;;
        unlink)
            cmd_unlink "$@"
            ;;
        edit)
            cmd_edit "$@"
            ;;
        help)
            cmd_help
            ;;
        *)
            print_error "Unknown command: $cmd"
            echo "Run '${SCRIPT_NAME} help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"